
import { GoogleGenAI, Modality, Part } from "@google/genai";
import type { UploadedFile } from "../types";
import { fileToBase64 } from "../utils";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export interface GenerateImagesPayload {
    modelFile: UploadedFile;
    otherFiles: {
        clothing?: UploadedFile;
        logo?: UploadedFile;
        product?: UploadedFile;
    };
    styles: string[];
    quality: string;
    aspect: string;
    count: number;
    userPrompt: string;
}

const generateSingleImage = async (payload: GenerateImagesPayload, retries = 2): Promise<string> => {
    try {
        const { modelFile, otherFiles, userPrompt, quality } = payload;

        const modelBase64 = await fileToBase64(modelFile.file);

        const parts: Part[] = [
            {
                inlineData: {
                    data: modelBase64,
                    mimeType: modelFile.file.type,
                },
            },
        ];

        if (otherFiles.product) {
            const productBase64 = await fileToBase64(otherFiles.product.file);
            parts.push({
                inlineData: {
                    data: productBase64,
                    mimeType: otherFiles.product.file.type,
                },
            });
        }

        if (otherFiles.clothing) {
            const clothingBase64 = await fileToBase64(otherFiles.clothing.file);
            parts.push({
                inlineData: {
                    data: clothingBase64,
                    mimeType: otherFiles.clothing.file.type,
                },
            });
        }

        if (otherFiles.logo) {
            const logoBase64 = await fileToBase64(otherFiles.logo.file);
            parts.push({
                inlineData: {
                    data: logoBase64,
                    mimeType: otherFiles.logo.file.type,
                },
            });
        }

        // The prompt is now a list of comma-separated keywords.
        // If a logo is provided, add an instruction to place it.
        // Finally, append the quality setting as another keyword.
        const promptParts = [userPrompt];
        if (otherFiles.logo) {
            promptParts.push("thêm logo được cung cấp vào góc trên bên phải của ảnh, đảm bảo nó nổi bật và hài hòa với tổng thể");
        }
        promptParts.push(`chất lượng ${quality}`);
        
        const finalPrompt = promptParts.join(', ');
        parts.push({
            text: finalPrompt,
        });
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: { parts },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        // Check for safety blocks
        if (response.promptFeedback?.blockReason) {
            throw new Error(`Request was blocked by the API due to safety concerns: ${response.promptFeedback.blockReason}`);
        }

        const candidate = response.candidates?.[0];

        // Check for candidate existence and finish reason
        if (!candidate) {
            throw new Error("No candidates were returned from the API. The request may have been filtered.");
        }
        if (candidate.finishReason && candidate.finishReason !== 'STOP') {
             throw new Error(`Image generation failed. The API stopped with reason: ${candidate.finishReason}`);
        }

        let generatedText = "";
        for (const part of candidate.content?.parts || []) {
            if (part.text) {
                generatedText += part.text;
            }
            if (part.inlineData) {
                const base64ImageBytes: string = part.inlineData.data;
                return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
            }
        }
        
        if (generatedText) {
            // Sometimes the model returns an explanation instead of an image
            throw new Error(`API returned the following text instead of an image: "${generatedText.trim()}"`);
        }

        throw new Error("No image was generated by the API. The response was empty or did not contain image data.");
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const isInternalError = errorMessage.includes("Internal error") || errorMessage.includes("500");

        if (retries > 0 && isInternalError) {
            console.warn(`API internal error. Retrying... (${retries} attempts left)`);
            // Simple backoff wait
            await new Promise(resolve => setTimeout(resolve, (3 - retries) * 1000));
            return generateSingleImage(payload, retries - 1);
        }

        throw error; // Re-throw if no retries left or not a retryable error
    }
};


export const generateImages = async (payload: GenerateImagesPayload): Promise<string[]> => {
    const { count } = payload;

    // Create an array of promises for generating each image
    const imagePromises: Promise<string>[] = [];
    for (let i = 0; i < count; i++) {
        imagePromises.push(generateSingleImage(payload));
    }
    
    // Wait for all image generation promises to resolve
    const imageUrls = await Promise.all(imagePromises);
    
    return imageUrls;
};
